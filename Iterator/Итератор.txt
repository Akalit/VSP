name.begin() 			указывает на начало переме
name.end()			указывает на конец переме
name.erase(name.begin(),name.begin()+3) удалить с начала 3 элем
.push_back(i + 1)   			добавляет + 1 к элем 
.resize(колво элем)		 изменяет розмер вектора

vector<int>b(2,20);

user.insert(user.end(),b.begin(),b.end()); 	добавляет в конец user все элем и  
 
vector<int> a;

vector<int>::iterator name = a.begin();    классный указатель)

for(name; name != a.end();name++)
cout << *name << endl; 				вывод всех элем мас от 0 до конца мас



 .resize(10,50)	-> функция изменяющая розмер контейнера, теперь он состоит из 10 элементов, если в контейнере было меньше 10 элементов 
то автоматически заполняеться 50ками до тех пор пока в контейнере не будет 10 чисел, если в контейнере было больше 10 числе , то все числа после 10 уничтожаються

.advance(i,5) -> ф_я где i это итератор а 5 это сдвих итератора на пять элем в ++; Так же можно и с -5 (сдвигает ИТЕРАТОР на 5 элем влево)

.insert(i, 1, 120) -> ф_я принемает в себя 3 знач i == адрес где стоит итератор 1 сколько элементов будет вставленно 120 число которое вставляется

.assign(5,66) -> заполняет контейнер 5ю числами 66

.sort(greater<int>()); ->сортирует контейнер от MAX -> MIN

int x[10] = { 1,3,5,7,9,2,4,6,8,10 };
std::sort(x, x + 10, std::less<int>());     // for ascending order 	по возрастанию   less = меньше
std::sort(x, x + 10, std::greater<int>());  // for descending order	по убыванию	greater = больше

.reverse() -> меняет в контенере значение в обратном порядке

li.merge(li1) -> функция соединения, в li будет добавлен li1

.unique() -> удаляет дубликаты (желаьельно отсортировать в начале)

distance(i1,i2) -> определяет дистанцию между 2мя итераторами

iter_swap(i1,i2) -> Меняет местами 2 элема

		

		vector<int> foo,bar;
		for (int i=1; i<=5; i++) { foo.push_back(i); bar.push_back(i*10);}
		
			copy (bar.begin(), bar.end(), back_inserter(foo)); ->Принемает 2 аргумента (2 итератора) в нашем случае на начало и конец, 3арргумент, функц смотрит в конец чем заполнин контенер и копирует в него инфу с 1-2 итераторов.


vector<int> v {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

fill_n(inserter(v, v.begin()), 3, -1); -> выполняет вставку элем в определённую позицию.  3 количество вставляемых элементов, -1 вставляемый элемент, v -> контейнер с которым производиться работа, v.begin() -> итератор на какое то место в контейнере .
То есть в нашем случае, функция inserter вернёт нам 3 раза ссылку на 1 элемент в контейнере в который и будет вставлено 3 раза число -1

		vector<string> s{"one", "two", "three"};

		vector<string> v1(s.begin(), s.end()); -> СКОПИРУЕМ в v1 значение итератора s.begin() и s.end(), то есть всё содержимое s
		vector<string> v2(make_move_iterator(s.begin()), make_move_iterator(s.end()));	-> ПЕРЕМЕСТИМ в v2 значение итератора s.begin() и s.end(), то есть всё содержимое s

		cout << "v1 now holds: ";
		for(auto str : v1)
				cout << str << ", ";

		cout << endl << "v2 now holds: ";
		for(auto str : v2)
				cout << str << ", ";

		cout << endl << "Original vector now holds: ";
		for(auto str : s)
				cout << str << ", ";
		cout << endl;
	} 